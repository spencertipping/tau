#include <iostream>
#include "../tau.hh"
#include "../sigma.hh"

using namespace τ;
using namespace std;


#include "../tau/begin.hh"


Ψ1 iota()
{
  return {[](ψ, ξo o, Ψaux)
    { for (i64 i = 1;; ++i) o.r(12) << i; }};
}

Γ weaken_eager()
{
  return new Γf_("weaken_eager", [](Ξc &x)
    { x.f().weaken();
      return x; });
}

Ψ2 weaken()
{
  return {[](ψ, ξi i, ξo o, Ψaux)
    { i.weaken();
      for (let x : i) o.r(x.osize()) << x.outer(); }};
}

Ψ2 take(i64 n)
{
  return {[n](ψ, ξi i, ξo o, Ψaux)
    { i64 e = 0;
      if (n)
        for (let x : i)
        { o.r(x.osize()) << x.outer();
          if (++e >= n) break; } }};
}

Ψ2 sum()
{
  return {[](ψ, ξi i, ξo o, Ψaux)
    { i64 t = 0;
      for (let x : i) o.r(12) << (t += x.i()); }};
}

Ψ2 last()
{
  return {[](ψ, ξi i, ξo o, Ψaux)
    { i64 y = 0;
      for (let x : i) y = x.i();
      o.r(12) << y; }};
}

Ψ2 debug(St prefix)
{
  return {[=](ψ, ξi i, ξo o, Ψaux)
    { for (let x : i)
      { cout << prefix << ": ";
        for (let y : x) cout << y << (y.has_next() ? " " : "");
        cout << endl;
        o.r(x.osize()) << x.outer(); } }};
}

Ψ0 print()
{
  return {[](ψ, ξi i, Ψaux)
    { for (let x : i)
      { for (let y : x) cout << y << (y.has_next() ? " " : "");
        cout << endl; } }};
}


Ψ1 forever_server(St p)
{
  return {[p](ψ q, ξo o, Ψaux)
    { q.b(p, [o](ψ &&q, Ξc &x)
      { let i = x.f();
        q.f([i, o]()
          { for (let x : i) o.r(x.osize()) << x.outer(); });
        return x.fx(); }); }, "forever_server:" + p, true};
}

Ψ2 server(St p)
{
  return {[p](ψ q, ξi i, ξo o, Ψaux)
    { q.b(p, [o](ψ &&q, Ξc &x)
      { let i = x.f();
        q.f([i, o]() { for (let x : i) o.r(x.osize()) << x.outer(); });
        return x.fx(); });

      // Provide a way to decommission the server, which should terminate
      // the ψ as soon as all client connections are done
      q.f([q, p, i]() mutable
        { for (let a : i)
            if (a.is_sig() && a.sig() == ηsig::ω)
              q.bx(p); }); },
    "server:" + p, true};
}

Γ connect(St port)
{
  return new Γf_{"connect:" + port, [port](Ξc &x)
    { return x.c(port); }};
}


slet p = φE(Γφ(φd<Γ>("Γ₁",
                     "push", φR(σ::Γpush()),
                     "drop", φR(σ::Γdrop()),
                     "we",   φR(weaken_eager()),
                     "C",    φm(φstr(), Sc<Γ(*)(St)>(connect))),
               φd<Ψ0>("Ψ₀",
                      "p",   φR(print())),
               φd<Ψ1>("Ψ₁",
                      "fS",  φm(φstr(), forever_server),
                      "i",   φR(iota())),
               φd<Ψ2>("Ψ₂",
                      "d",   φm(φstr(), debug),
                      "wl",  φR(weaken()),
                      "s",   φR(sum()),
                      "S",   φm(φstr(), Sc<Ψ2(*)(St)>(server)),
                      "l",   φR(last()),
                      "t",   φm(φint(), take)),
               φF<Ψ4>()).second);


void try_gc1()
{
  τe t;
  // weaken_eager() should immediately free iota()
  p("push i we slp").r()(Ξ{t});
  t.go();
  A(!ξn(), "ξs outlived try_gc: " << ξn());
  A(!ψn(), "ψs outlived try_gc: " << ψn());
}

void try_gc2()
{
  τe t;
  // weaken() should immediately free iota()
  p("push i wl slp").r()(Ξ{t});
  t.go();
  A(!ξn(), "ξs outlived try_gc: " << ξn());
  A(!ψn(), "ψs outlived try_gc: " << ψn());
}


void try_iota()
{
  τe t;
  p("push i t10 slp").r()(Ξ{t});
  t.go();
  A(!ξn(), "ξs outlived try_iota: " << ξn());
  A(!ψn(), "ψs outlived try_iota: " << ψn());
}


void try_iota_rev()
{
  τe t;
  p("push \\p\\l\\s\\t1000\\i").r()(Ξ{t});
  t.go();
  A(!ξn(), "ξs outlived try_iota_rev: " << ξn());
  A(!ψn(), "ψs outlived try_iota_rev: " << ψn());
}


void try_iota_loop()
{
  τe t;
  p("push \\p\\l it10000 |s").r()(Ξ{t});
  t.go();
  A(!ξn(), "ξs outlived try_iota_loop: " << ξn());
  A(!ψn(), "ψs outlived try_iota_loop: " << ψn());
}


void try_server_simple()
{
  {
    τe t;
    p("push fS\"p\" st20lp drop "
      "push it10 C\"p\" drop "
      "push it10 C\"p\" drop").r()(Ξ{t});
    t.go();

    A(!ξn(), "ξs outlived try_server_simple: " << ξn());
    A(ψn() == 1, "more than one ψ outlived try_server_simple: " << ψn());
  }
  A(!ψn(), "ψ outlived τ");
}


int main()
{
  τassert_begin;
  try_gc1();
  try_gc2();
  try_iota();
  try_iota_rev();
  try_iota_loop();
  try_server_simple();
  return 0;
  τassert_end;
}


#include "../tau/end.hh"
