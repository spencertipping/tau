#!/usr/bin/env perl
use strict;
use warnings;

exit tau::compile::main(@ARGV);
BEGIN {
#line 1 "tau::p/map.pm"
package tau::map;

use Encode       qw/decode/;
use List::Util   qw/max/;
use Scalar::Util qw/openhandle/;

use constant news_vectors => {n => [ 0, -1],
                              e => [ 1,  0],
                              w => [-1,  0],
                              s => [ 0,  1]};


our %news_cache;
sub news
{
  my ($s) = @_;
  return @{$news_cache{$s}} if exists $news_cache{$s};

  my ($x, $y) = (0, 0);
  for (split //, $s)
  {
    my ($dx, $dy) = @{news_vectors->{$_}};
    $x += $dx;
    $y += $dy;
  }
  @{$news_cache{$s} = [$x, $y]};
}


sub new
{
  my ($class, $f) = @_;
  my %m;
  my $y  = 0;
  my $mx = 0;

  open my $fh, "<", $f or die "open < $f: $!";

  while (defined(my $l = <$fh>))
  {
    chomp $l;
    $l = decode 'UTF-8', $l;
    $m{pack LL => $_, $y} = ord substr $l, $_, 1 for 0..length($l)-1;
    $mx = max $mx, length($l) - 1;
    ++$y;
  }

  $m{mx} = $mx;
  $m{my} = $y - 1;

  # Fill voids with spaces so strings will be populated regardless of
  # whitespace formatting
  for my $x (0..$m{mx}) { $m{pack LL => $x, $_} //= 32 for 0..$m{my} }

  bless \%m, $class;
}


sub n      { scalar(keys %{+shift}) - 2 }
sub bounds { @{+shift}{qw/mx my/} }
sub at     { ${+shift}{pack LL => @_} }


sub has
{
  my ($self, $x, $y) = @_;
  my $n = $self->at($x, $y);
  defined $n && $n != 32;
}


sub str
{
  my $self = shift;
  my ($mx, $my) = $self->bounds;
  my @ls;
  for my $y (0..$my)
  {
    push @ls, join"", map chr, grep defined, map $self->at($_, $y), 0..$mx;
  }
  join"\n", @ls;
}


sub next
{
  my ($self, $x, $y, $news) = @_;
  my ($dx, $dy) = news $news;
  my ($mx, $my) = $self->bounds;

  $x += $dx;
  $y += $dy;

  while ($x >= 0 && $x <= $mx && $y >= 0 && $y <= $my)
  {
    my $c = $self->at($x, $y);
    return ($x, $y, chr $c) if defined $c && $c != 32;
    $x += $dx;
    $y += $dy;
  }
}


sub sub
{
  my ($self, $x, $y, $news, $n) = (@_, 0);
  my ($dx, $dy) = news $news;
  my $s = '';
  while (defined $self->at($x, $y) and !$n || length $s < $n)
  {
    $s .= chr $self->at($x, $y);
    $x += $dx;
    $y += $dy;
  }
  $s;
}
}
BEGIN {
#line 1 "tau::p/peg2.pm"
package tau::peg2;

use Exporter 'import';
use List::Util qw/max/;

our @EXPORT_OK = qw/all any multir dspr k seq rep bow seek
                    is pmap pgrep pflatmap re/;

our %EXPORT_TAGS = (all => \@EXPORT_OK);


sub all
{
  my @ps = @_;
  sub
  {
    my ($m, $x, $y) = @_;
    my @r;
    defined(@r = &$_($m, $x, $y)) || return undef for @ps;
    @r;
  };
}


sub any
{
  my @ps = @_;
  sub
  {
    my ($m, $x, $y) = @_;
    my @r;
    defined(@r = &$_($m, $x, $y)) && return @r for @ps;
    undef;
  };
}


sub multir(\%)
{
  my ($ps) = @_;
  sub
  {
    my ($m, $x, $y) = @_;
    my ($rx, $ry, @rv, %rc, %rv);
    while (my ($k, $p) = each %$ps)
    {
      if (defined(($rx, $ry, @rv) = &$p($m, $x, $y)))
      {
        $rv{$k} = [@rv];
        $rc{$k} = [$rx, $ry];
      }
    }
    (\%rc, \%rv);
  };
}


sub dspr(\%$)
{
  my ($ps, $news) = @_;
  my ($dx, $dy) = tau::map::news $news;
  sub
  {
    my ($m, $x, $y) = @_;
    my $ml = max map length, keys %$ps;
    my ($p, $rx, $ry, @rv);
    for my $l (map $ml - $_, 0..$ml-1)
    {
      my $k = $m->sub($x, $y, $news, $l);
      return ($rx, $ry, $k, @rv)
          if defined($p = $$ps{$k})
          && defined(($rx, $ry, @rv) = &$p($m, $x + $l*$dx, $y + $l*$dy));
    }
    undef;
  };
}


sub k
{
  my ($s, $news) = @_;
  my ($dx, $dy)  = tau::map::news $news;
  my $n          = length $s;
  sub
  {
    my ($m, $x, $y) = @_;
    $m->sub($x, $y, $n) eq $s
        ? ($x + $dx * $n, $y + $dy * $n, $s)
        : undef;
  };
}


sub seq
{
  my @ps = @_;
  sub
  {
    my ($m, $x, $y) = @_;
    my @r;
    my @rvs;
    for (@ps)
    {
      return undef unless defined(@r = &$_($m, $x, $y));
      $x = shift @r;
      $y = shift @r;
      push @rvs, @r;
    }
    ($x, $y, @rvs);
  };
}


sub rep
{
  my ($p, $max) = (@_, -1 | 0);
  sub
  {
    my ($m, $x, $y) = @_;
    my @r;
    my @rvs;
    while (defined(@r = &$p($m, $x, $y)))
    {
      $x = shift @r;
      $y = shift @r;
      push @rvs, @r;
    }
    ($x, $y, @rvs);
  };
}


sub bow    # beginning of word
{
  my ($news) = @_;
  my ($dx, $dy) = tau::map::news $news;
  sub
  {
    my ($m, $x, $y) = @_;
    $m->has($x - $dx, $y - $dy) ? undef : ($x, $y);
  };
}


sub seek
{
  my ($news) = @_;
  sub
  {
    my ($m, $x, $y) = @_;
    my @r;
    defined(@r = $m->next($x, $y, $news)) ? @r : undef;
  };
}


sub is
{
  my ($c) = @_;
  $c = ord $c if $c !~ /^\d+$/;
  sub
  {
    my ($m, $x, $y) = @_;
    $m->at($x, $y) == $c ? ($x, $y) : undef;
  };
}


sub pmap(&$)
{
  my ($f, $p) = @_;
  sub
  {
    my ($m, $x, $y) = @_;
    my @r;
    return undef unless defined(($x, $y, @r) = &$p($m, $x, $y));
    ($x, $y, &$f(@r));
  };
}


sub pgrep(&$)
{
  my ($f, $p) = @_;
  sub
  {
    my ($m, $x, $y) = @_;
    my @r;
    return undef unless defined(($x, $y, @r) = &$p($m, $x, $y));
    &$f(@r) ? ($x, $y, @r) : undef;
  };
}


sub pflatmap(&$)
{
  my ($f, $p) = @_;
  sub
  {
    my ($m, $x, $y) = @_;
    my @r;
    return undef unless defined(($x, $y, @r) = &$p($m, $x, $y));
    my $p2;
    return undef unless defined($p2 = &$f($m, $x, $y, @r));
    &$p2($m, $x, $y);
  };
}


sub re
{
  my ($re, $news) = @_;
  my ($dx, $dy) = tau::map::news $news;
  sub
  {
    my ($m, $x, $y) = @_;
    my $s = $m->sub($x, $y, $news);
    $s =~ s/^($re)//
        ? ($x + $dx * length $1, $y + $dy * length $1, @{^CAPTURE})
        : undef;
  };
}
}
BEGIN {
#line 1 "tau::p/grammar.pm"
package tau::grammar;

use Exporter 'import';
BEGIN { tau::peg2->import(':all') }


# TODO
# We need an expression language that does prefix dispatch, just like ni.
# We also need north/south default placements for aux data.
# And `:` binding sections.

# TODO: horizontal whitespace delimiters

use constant expr => re qr/.*/, 'e';


use constant pstart => sub
{
  my ($m, $x, $y) = @_;
  return pstream->($m, $x, $y) if $m->at($x, $y) == ord '=';

  my ($sx, $sy, $c) = $m->next($x, $y, 's');
  return undef unless $c eq '=';
  pstream->($m, $sx, $sy);
};
}
BEGIN {
#line 1 "tau::p/compile.pm"
package tau::compile;


sub main
{
  my ($source) = @_;
  my $map = tau::map->new($source);

  my ($x, $y, @code) = tau::grammar::pstart->($map, 0, 0);
  print "$x $y @code\n";
}
}
